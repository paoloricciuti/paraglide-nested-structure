/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols
// Generated by unplugin-auto-import
export {}
declare global {
	type Msgs = typeof import('$msgs');

	type AddField<Obj extends {}, Field extends string, Value> = {
		[K in keyof Obj]: Obj[K];
	} & {
		[K in Field]: Value;
	};

	type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
		k: infer I
	) => void
		? I
		: never;

	type LastOf<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R
		? R
		: never;

	type Push<T extends any[], V> = [...T, V];

	type ToTuple<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N
		? []
		: Push<ToTuple<Exclude<T, L>>, L>;

	type ComputeKey<
		Str extends string,
		Result extends Record<string, any>,
		Original = Str
	> = Str extends `${infer Something extends string}_${infer Rest}`
		? AddField<Result, Something, ComputeKey<Rest, Result, Original>>
		: AddField<Result, Str, Msgs[Original]>;

	type FlatToNested<
		KeysTuple extends string[],
		Result extends Record<string, any> = {},
		Acc extends unknown[] = [],
		Curr = KeysTuple[Acc['length']]
	> = Curr extends string
		? ComputeKey<Curr, Result> & FlatToNested<KeysTuple, Result, [...Acc, 1]>
		: Result;

	const m: FlatToNested<ToTuple<keyof Msgs>>;
}
